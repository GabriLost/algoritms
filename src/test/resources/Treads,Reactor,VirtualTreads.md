## Глоссарий

| Термин              | Описание                                                                                                                                |
| ------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| Платформенный поток | Обычный поток в Java, классический, обёртка над Системным потоком, так же называется kernel tread, создание занимает 2mb, занимает 15ms |
| Виртуальный поток   | фича из Project Loom, которая переместит состояние потока в heap, когда он не использует процессор                                      |
Вопросы:
1. в чем разница между системными тредами, платформенными тредами?
2. Какие операции являются блокирующими?
3. fork and join
4. реактивное программирование это многопоточка или нет?
5. почему бы нам всегда не использовать виртуальные потоки? например у нас есть задача, которую можно распараллелить

Обсуждение:
1. fire and forget - как обход блокировки?

## Подход на Treads
Создавать по одному треду на один запрос очень дорого, 2mb, 15ms. так при миллионе запросов уйдёт 2тб памяти и 15 минут на создание потоков. 

2 выхода из этой ситуации, либо переиспользовать существующие потоки, либо нужен новый тип тредов (который в 1 000 000 раз лучше, чем обычный).
Так или иначе мы не можем больше писать в императивном виде.
Все операции придётся писать как лямбды, используя асинхронные фреймворки. 

Фремфорк должен уметь запустить операцию и разблокировать поток, чтобы тот мог заняться полезной работой. 

Примеры
110 - простота понимания
111 - сложность понимания и сложность найти ошибку, потому что не в стектрейсе, если ошибку обработаете внутри функции, то отлично, но если одина из лябд вернёт null, удачи найти где эта ошибка.

В чем проблема-то? нужно повысить использование CPU
## Project Reactor
Упрощает работу с асинхронным кодом 

| Плюсы                                                                                                                                                                                                                                   | Минусы                                                                                                                     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- |
| - неблокирующие вызовы <br>- ленивая загрузка данных<br>- удобная обработка потоков, ошибок, похоже на стримы<br>- отмена обработки, cancel propagination (особенно если локально выполняется)<br>- backpressure? ещё не разобрался<br> | - сложно поддерживать<br>огромные стектресы для ошибок, попробуй найди почему у тебя NPE вылетел<br>- сложно для понимания |

В целом реактивный подход сейчас развивается,
есть еще JavaRx. 


Один из моих любимых примеров - это просмотр информации по фильму, а именно загрузка рекомендаций к текущему фильму для пользователя, можно ограничить поток как по количеству элементов, так и по времени выполнения, чтобы "неважный" запрос не влиял на выполнение всего запроса. 
## Java 21 и Виртуальные потоки
Виртуальные потоки настолько лёгкие, что нам не нужно создавать их пулл. 
Магии нет, мы просто запускаем несколько задач на платформенных тредах, по-другому быть не может. 

1. Не стоит запускать virtual threads для локальных вычислений - для Stream'ов и in-memory задач лучше использовать обычные платформенные потоки.
2. Есть overhead на создание виртуальных потоков, поэтому их желательно использовать  для I\O или блокирующих задачах

Множество проектов уже работают на виртуальных потоках - Jetty, Vertx, Tomcat, Spring, Quarqus, Helidon


Поддержка в AppFarm
 [Соответствие значений `STACK_VERSION` и версий образов, используемых платформой](https://platform-user-manual.rshbdev.ru/#/technology/jvm/maven_rules?id=%d0%a1%d0%be%d0%be%d1%82%d0%b2%d0%b5%d1%82%d1%81%d1%82%d0%b2%d0%b8%d0%b5-%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b9-stack_version-%d0%b8-%d0%b2%d0%b5%d1%80%d1%81%d0%b8%d0%b9-%d0%be%d0%b1%d1%80%d0%b0%d0%b7%d0%be%d0%b2-%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d1%83%d0%b5%d0%bc%d1%8b%d1%85-%d0%bf%d0%bb%d0%b0%d1%82%d1%84%d0%be%d1%80%d0%bc%d0%be%d0%b9)

Ссылки: 
1. [Concurrency в Spring Boot приложениях habr](https://habr.com/ru/companies/spring_aio/articles/862950/)
2. [OTUS Вирутальные потоки](https://www.youtube.com/watch?v=mgX7bj9jjpQ)
3. [Java 21 new feature: Virtual Threads](https://www.youtube.com/watch?v=5E0LU85EnTI&ab_channel=Java)
4. [Reactive by Oleh Dokuka, контрибьютор ProjectReactor](https://www.youtube.com/watch?v=uBUDM3dVD3A&ab_channel=DevoxxPoland)